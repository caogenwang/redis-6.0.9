1. Redis缓存有哪些淘汰策略?
    不进行数据淘汰的策略，只有noeviction这一种

    在设置了过期时间的数据中进行淘汰，包括volatile-random、volatile-ttl、volatile-lru、volatile-lfu四种
    在所有数据范围内进行淘汰，包括allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0后新增）三种

2. 优先使用allkeys-lru策略。这样，可以充分利用LRU这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用allkeys-lru策略。
如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用allkeys-random策略，随机选择淘汰的数据就行。
如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用volatile-lru策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据LRU规则进行筛选。


3. 如何处理被淘汰的数据？
    一般来说，一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；
    如果这个数据是脏数据，我们需要把它写回数据库。就是被修改过了，需要和数据库同步

    这么一来，缓存替换既腾出了缓存空间，用来缓存新的数据，同时，将脏数据写回数据库，
    也保证了最新数据不会丢失

4. 从淘汰数据的候选集范围来看，我们有两种候选范围：
    一种是所有数据都是候选集，一种是设置了过期时间的数据是候选集

5. 当然，设置缓存容量的大小也很重要，我的建议是：
    结合实际应用的数据总量、热数据的体量，以及成本预算，把缓存空间大小设置在总数据量的15%到30%这个
    区间就可以

Redis在用作缓存时，使用只读缓存或读写缓存的哪种模式？

1、只读缓存模式：每次修改直接写入后端数据库，如果Redis缓存不命中，则什么都不用操作，如果Redis缓存命中，
   则删除缓存中的数据，待下次读取时从后端数据库中加载最新值到缓存中。
2、读写缓存模式+同步直写策略：由于Redis在淘汰数据时，直接在内部删除键值对，外部无法介入处理脏数据写回
   数据库，所以使用Redis作读写缓存时，只能采用同步直写策略，修改缓存的同时也要写入到后端数据库中，从
   而保证修改操作不被丢失。但这种方案在并发场景下会导致数据库和缓存的不一致，需要在特定业务场景下或者配
   合分布式锁使用。

   当一个系统引入缓存时，需要面临最大的问题就是，如何保证缓存和后端数据库的一致性问题，
   最常见的3个解决方案分别是Cache Aside、Read/Write Throught和Write Back缓存更新策略。
1、Cache Aside策略：就是文章所讲的只读缓存模式。读操作命中缓存直接返回，否则从后端数据库加载到缓存
                   再返回。写操作直接更新数据库，然后删除缓存。这种策略的优点是一切以后端数据库为准，
                   可以保证缓存和数据库的一致性。缺点是写操作会让缓存失效，再次读取时需要从数据库中
                   加载。这种策略是我们在开发软件时最常用的，在使用Memcached或Redis时一般都采用这
                   种方案。
2、Read/Write Throught策略：应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，
                   缓存层会自动从数据库中加载或写回到数据库中，这种策略的优点是，对于应用层的使用
                   非常友好，只需要操作缓存即可，缺点是需要缓存层支持和后端数据库的联动。
3、Write Back策略：类似于文章所讲的读写缓存模式+异步写回策略。写操作只写缓存，比较简单。
                  而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，
                  如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。
                  这种策略的优点是，写操作飞快（只写缓存），缺点是如果数据还未来得及写入后端数据库，
                  系统发生异常会导致缓存和数据库的不一致。这种策略经常使用在操作系统Page Cache中，
                  或者应对大量写操作的数据库引擎中。


在实际运行时，每次往候选集中插入的数据可能不止一个，而在淘汰数据时，也是会根据使用内存量超过
maxmemory的情况，来决定要淘汰的数据量，所以可能也不止一个数据被淘汰。候选集的作用是先把符合条件
（lru值小）的数据准备好。候选集本身是会按照lru值大小排序的，等待要淘汰时，会根据要淘汰的量，
从候选集中淘汰数据。所以，并不是刚进入候选集就立马就淘汰了。准备候选集和淘汰数据实际是两个解耦的
逻辑操作

除了以上提到的缓存和数据库的更新策略之外，还有一个问题就是操作缓存或数据库发生异常时如何处理？
例如缓存操作成功，数据库操作失败，或者反过来，还是有可能会产生不一致的情况。
比较简单的解决方案是，根据业务设计好更新缓存和数据库的先后顺序来降低影响，
或者给缓存设置较短的有效期来降低不一致的时间。如果需要严格保证缓存和数据库的一致性，
即保证两者操作的原子性，这就涉及到分布式事务问题了，
常见的解决方案就是我们经常听到的两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列等方式来保证了，
方案也会比较复杂，一般用在对于一致性要求较高的业务场景中    

问题1：
    1. 淘汰对当前请求的延迟问题；(如果是同步删除会对当前主线程存在影响，尤其是删除量比较大或者bigkey；对于懒惰删除，异步执行删除操作影响不大；)
    2. 淘汰数据的上限是多少？仅满足当前set所需的内存空间么？（已经使用的大小 - 最大可以使用的大小）
    3. 如果随机多次依然不存在比候选队列中最小lru还小的数据，且内存空间还需要继续释放，是否有执行时间上限？

