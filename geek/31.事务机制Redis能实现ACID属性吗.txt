事务是数据库的一个重要功能。所谓的事务，就是指对数据进行读写的一系列操作。
事务在执行时，会提供专门的属性保证，包括原子性（Atomicity）、一致性（Consistency）、
隔离性（Isolation）和持久性（Durability），也就是ACID属性

1. 事务ACID属性的要求
    原子性: 原子性的要求很明确，就是一个事务中的多个操作必须都完成，或者都不完成。
            业务应用使用事务时，原子性也是最被看重的一个属性

2. Redis如何实现事务
    Redis提供了MULTI、EXEC两个命令来完成这三个步骤

    第一步，客户端要使用一个命令显式地表示一个事务的开启
    第二步，客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端
    第三步，客户端向服务器端发送提交事务的命令，让数据库实际执行第二步中发送的具体操作

        #开启事务
        127.0.0.1:6379> MULTI
        OK
        #将a:stock减1，
        127.0.0.1:6379> DECR a:stock
        QUEUED
        #将b:stock减1
        127.0.0.1:6379> DECR b:stock
        QUEUED
        #实际执行事务
        127.0.0.1:6379> EXEC
        1) (integer) 4
        2) (integer) 9

3. Redis的事务机制能保证哪些属性
    原子性
        如果事务正常执行，没有发生任何错误，那么，MULTI和EXEC配合使用，就可以保证多个操作都完成。
        但是，如果事务执行发生错误了，原子性还能保证吗？
        
        第一种情况，在执行EXEC命令前，客户端发送的操作命令本身就有错误（比如语法错误，使用了不存在的命令），在命令入队时就被Redis实例判断出来了。
            对于这种情况，在命令入队时，Redis就会报错并且记录下这个错误。此时，我们还能继续提交命令操作。
            等到执行了EXEC命令之后，Redis就会拒绝执行所有提交的命令操作，返回事务失败的结果。
            这样一来，事务中的所有命令都不会再被执行了，保证了原子性。
        
        第二种情况，事务操作入队时，命令和操作的数据类型不匹配，但Redis实例没有检查出错误。
            但是，在执行完EXEC命令以后，Redis实际执行这些事务操作时，就会报错。不过，需要注意的是，
            虽然Redis会对错误命令报错，但还是会把正确的命令执行完。在这种情况下，事务的原子性就无法
            得到保证了

        命令入队时就报错，会放弃事务执行，保证原子性；
        命令入队时没报错，实际执行时报错，不保证原子性；
        EXEC命令执行时实例故障，如果开启了AOF日志，可以保证原子性。   

    一致性：就是指数据库中的数据在事务执行前后是一致的
        事务的一致性保证会受到错误命令、实例故障的影响。所以，我们按照命令出错和实例故障的发生时机，
        分成三种情况来看

        情况一：命令入队时就报错：在这种情况下，事务本身就会被放弃执行，所以可以保证数据库的一致性
        情况二：命令入队时没报错，实际执行时报错：有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性
        情况三：EXEC命令执行时实例发生故障：在这种情况下，实例故障后会进行重启，这就和数据恢复的方式有关了，我们要根据实例是否开启了RDB或AOF来分情况讨论下
                如果我们没有开启RDB或AOF，那么，实例故障重启后，数据都没有了，数据库是一致的
                如果我们使用了RDB快照，因为RDB快照不会在事务执行时执行，所以，事务命令操作的结果不会被保存到RDB快照中，使用RDB快照进行恢复时，数据库里的数据也是一致的
                如果我们使用了AOF日志，而事务操作还没有被记录到AOF日志时，实例就发生了故障，那么，使用AOF日志恢复的数据库数据是一致的。如果只有部分操作被记录到了AOF日志，我们可以使用redis-check-aof清除事务中已经完成的操作，数据库恢复后也是一致的
    
    隔离性：它要求数据库在执行一个事务时，其它操作无法存取到正在执行事务访问的数据
            并发操作在EXEC命令前执行，此时，隔离性的保证要使用WATCH机制来实现，否则隔离性无法保证；
            并发操作在EXEC命令后执行，此时，隔离性可以保证
        
            第一种情况
                一个事务的EXEC命令还没有执行时，事务的命令操作是暂存在命令队列中的。此时，如果有其它的并发操作，我们就需要看事务是否使用了WATCH机制
    持久性：数据是否持久化保存完全取决于Redis的持久化配置模式
        管Redis采用什么持久化模式，事务的持久性属性是得不到保证的

问题：
    在执行事务时，如果 Redis 实例发生故障，而 Redis 使用的 RDB 机制，事务的原子性还能否得到保证？
    我觉得是可以保证原子性的。
    如果一个事务只执行了一半，然后 Redis 实例故障宕机了，由于RDB不会在事务执行时执行，所以 RDB 文件中不会记录只执行了一部分的结果数据。之后用 RDB 恢复实例数据，恢复的还是事务之前的数据。但 RDB 本身是快照持久化，所以会存在数据丢失，丢失的是距离上一次 RDB 之间的所有更改操作。
    关于 Redis 事务的使用，有几个细节我觉得有必要补充下，关于 Pipeline 和 WATCH 命令的使用。
    1、在使用事务时，建议配合 Pipeline 使用。
    a) 如果不使用 Pipeline，客户端是先发一个 MULTI 命令到服务端，客户端收到 OK，然后客户端再发送一个个操作命令，客户端依次收到 QUEUED，最后客户端发送 EXEC 执行整个事务（文章例子就是这样演示的），这样消息每次都是一来一回，效率比较低，而且在这多次操作之间，别的客户端可能就把原本准备修改的值给修改了，所以无法保证隔离性。
    b) 而使用 Pipeline 是一次性把所有命令打包好全部发送到服务端，服务端全部处理完成后返回。这么做好的好处，一是减少了来回网络 IO 次数，提高操作性能。二是一次性发送所有命令到服务端，服务端在处理过程中，是不会被别的请求打断的（Redis单线程特性，此时别的请求进不来），这本身就保证了隔离性。我们平时使用的 Redis SDK 在使用开启事务时，一般都会默认开启 Pipeline 的，可以留意观察一下。
    2、关于 WATCH 命令的使用场景。
    a) 在上面 1-a 场景中，也就是使用了事务命令，但没有配合 Pipeline 使用，如果想要保证隔离性，需要使用 WATCH 命令保证，也就是文章中讲 WATCH 的例子。但如果是 1-b 场景，使用了 Pipeline 一次发送所有命令到服务端，那么就不需要使用 WATCH 了，因为服务端本身就保证了隔离性。
    b) 如果事务 + Pipeline 就可以保证隔离性，那 WATCH 还有没有使用的必要？答案是有的。对于一个资源操作为读取、修改、写回这种场景，如果需要保证事物的原子性，此时就需要用到 WATCH 了。例如想要修改某个资源，但需要事先读取它的值，再基于这个值进行计算后写回，如果在这期间担心这个资源被其他客户端修改了，那么可以先 WATCH 这个资源，再读取、修改、写回，如果写回成功，说明其他客户端在这期间没有修改这个资源。如果其他客户端修改了这个资源，那么这个事务操作会返回失败，不会执行，从而保证了原子性。
    细节比较多，如果不太好理解，最好亲自动手试一下