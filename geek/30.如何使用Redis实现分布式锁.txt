在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁是保存在一个共享存储系统中的
可以被多个客户端共享访问和获取.

1. 锁变量需要由一个共享存储系统来维护，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。
    相应的，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值

    我们就可以得出实现分布式锁的两个要求。

        要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，
                我们需要保证这些锁操作的原子性；
        要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。
                在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。

2. 基于单个Redis节点实现分布式锁
    因为加锁包含了三个操作（读取锁变量、判断锁变量值以及把锁变量值设置为1），
    而这三个操作在执行时需要保证原子性。那怎么保证原子性呢？
    
    要想保证操作的原子性，有两种通用的方法，分别是使用Redis的单命令操作和使用Lua脚本

3. Redis可以用哪些单命令操作实现加锁操作?
    首先是SETNX命令，它用于设置键值对的值。具体来说，就是这个命令在执行时会判断键值对是否存在，
    如果不存在，就设置键值对的值，如果存在，就不做任何设置.

    存在的问题1：假如某个客户端在执行了SETNX命令、加锁之后，紧接着却在操作共享数据时发生了异常，
               结果一直没有执行最后的DEL命令释放锁。导致这个锁一直被持有，其他客户端没有办法再
               获取锁。

               解决方法：给key增加一个过期时间
    
    存在的问题2：如果客户端A执行了SETNX命令加锁后，假设客户端B执行了DEL命令释放锁，此时，客户端A的锁就被误释放了。
                此时就会两个客户端共同操作同一份数据。

                解决方法：给每个客户端做一个唯一标识，删除key的时候，判断一下是不是同一个客户端

4. 基于多个Redis节点实现高可靠的分布式锁
    为了避免Redis实例故障而导致的锁无法工作的问题，Redis的开发者Antirez提出了分布式锁算法Redlock。

    Redlock算法的基本思路，是让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例
    成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个
    Redis实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不
    会丢失。

    第一步是，客户端获取当前时间。

    第二步是，客户端按顺序依次向N个Redis实例执行加锁操作

    第三步是，一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁过程的总耗时

    客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
    条件一：客户端从超过半数（大于等于 N/2+1）的Redis实例上成功获取到了锁；
    条件二：客户端获取锁的总耗时没有超过锁的有效时间。

    在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁
    的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，
    锁就过期了的情况。

    问题：
    按照惯例，我给你提个小问题。这节课，我提到，我们可以使用SET命令带上NX和EX/PX选项进行加锁操作，
    那么，我想请你再思考一下，我们是否可以用下面的方式来实现加锁操作呢？

    // 加锁
    SETNX lock_key unique_value
    EXPIRE lock_key 10S
    // 业务逻辑
    DO THINGS

是否可以使用 SETNX + EXPIRE 来完成加锁操作？无法保证原子性

不可以这么使用。使用 2 个命令无法保证操作的原子性，在异常情况下，加锁结果会不符合预期。异常情况主要分为以下几种情况：
1、SETNX 执行成功，执行 EXPIRE 时由于网络问题设置过期失败
2、SETNX 执行成功，此时 Redis 实例宕机，EXPIRE 没有机会执行
3、SETNX 执行成功，客户端异常崩溃，EXPIRE 没有机会执行
如果发生以上情况，并且客户端在释放锁时发生异常，没有正常释放锁，那么这把锁就会一直无法释放，其他线程都无法再获得锁。