1. Redis缓存具体是怎么工作的？
2. Redis缓存如果满了，该怎么办？
3. 为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？
4. Redis的内存毕竟有限，如果用快速的固态硬盘来保存数据，
    可以增加缓存的数据量，那么，Redis缓存可以使用快速固态硬盘吗？


5. 计算机系统中，默认有两种缓存：
    CPU里面的末级缓存，即LLC，用来缓存内存中的数据，避免每次从内存中存取数据；
    内存中的高速页缓存，即page cache，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。
    
6. 第一个特征：在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，
        能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis就是快速子系统，而数据库就是慢速子系统了。
   第二个特征：缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。

7. Redis缓存处理请求的两种情况
    把Redis用作缓存时，我们会把Redis部署在数据库的前端，业务应用在访问数据时，会先查询Redis中是否保存了相应的数据。
    此时，根据数据是否存在缓存中，会有两种情况:
    1. 缓存命中：Redis中有相应数据，就直接读取Redis，性能非常快。
    2. 缓存缺失：Redis中没有保存相应数据，就从后端数据库中读取数据，
        性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入Redis，
        这个过程叫作缓存更新。缓存更新操作会涉及到保证缓存和数据库之间的数据一致性问题
8. String cacheKey = “productid_11010003”;
    String cacheValue = redisCache.get(cacheKey)；
    //缓存命中
    if ( cacheValue != NULL)
    return cacheValue;
    //缓存缺失
    else
    cacheValue = getProductFromDB();
    redisCache.put(cacheValue)  //缓存更新

9. Redis做缓存时，还有两种模式，分别是只读缓存和读写缓存。其中，读写缓存还提供了
    同步直写和异步写回这两种模式，同步直写模式侧重于保证数据可靠性，而异步写回模式则侧重于
    提供低延迟访问，我们要根据实际的业务场景需求来进行选择。

10.Redis只读缓存和使用直写策略的读写缓存，这两种缓存都会把数据同步写到后端数据库中，它们的区别在于：

1、使用只读缓存时，是先把修改写到后端数据库中，再把缓存中的数据删除。当下次访问这个数据时，会以后端数据库中的值为准，重新加载到缓存中。这样做的优点是，数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。缺点是每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。

2、使用读写缓存时，是同时修改数据库和缓存中的值。这样做的优点是，被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存，不用再从后端数据库中查询，这个过程拥有比较好的性能，比较适合先修改又立即访问的业务场景。但缺点是在高并发场景下，如果存在多个操作同时修改同一个值的情况，可能会导致缓存和数据库的不一致。

3、当使用只读缓存时，如果修改数据库失败了，那么缓存中的数据也不会被删除，此时数据库和缓存中的数据依旧保持一致。而使用读写缓存时，如果是先修改缓存，后修改数据库，如果缓存修改成功，而数据库修改失败了，那么此时数据库和缓存数据就不一致了。如果先修改数据库，再修改缓存，也会产生上面所说的并发场景下的不一致。

我个人总结，只读缓存是牺牲了一定的性能，优先保证数据库和缓存的一致性，它更适合对于一致性要求比较要高的业务场景。而如果对于数据库和缓存一致性要求不高，或者不存在并发修改同一个值的情况，那么使用读写缓存就比较合适，它可以保证更好的访问性能